#!/bin/bash

# Run command/application and choose paths/files with fzf.
# Always return control of the terminal to user (e.g. when opening GUIs).
# The full command that was used will appear in your history just like any
# other (N.B. to achieve this I write the shell's active history to
# ~/.bash_history)
#
# Usage:
# f cd [OPTION]... (hit enter, choose path)
# f cat [OPTION]... (hit enter, choose files)
# f vim [OPTION]... (hit enter, choose files)
# f vlc [OPTION]... (hit enter, choose files)

f() {
    # if no arguments passed, just lauch fzf
    if [ $# -eq 0 ]
    then
        fzf
        return 0
    fi

    # Store the program
    program="$1"

    # Remove first argument off the list
    shift

    # Store option flags with separating spaces, or just set as single space
    options="$@"
    if [ -z "${options}" ]; then
        options=" "
    else
        options=" $options "
    fi

    # Store the arguments from fzf
    arguments=$(fzf --multi)

    # If no arguments passed (e.g. if Esc pressed), return to terminal
    if [ -z "${arguments}" ]; then
        return 1
    fi

    # We want the command to show up in our bash history, so write the shell's
    # active history to ~/.bash_history. Then we'll also add the command from
    # fzf, then we'll load it all back into the shell's active history
    history -w

    # add a repeatable command to the bash history
    # sanitise the arguments before being entered into bash history
    for arg in "${arguments[@]}"; do
        arguments=$(echo "$arg" | sed "s/'/''/g; s/.*/'&'/g; s/\n//g")
    done

    # If the program is on the GUI list, add a '&'
    if [[ "$program" =~ ^(nautilus|zathura|evince|vlc|eog|kolourpaint)$ ]]; then
        arguments="$arguments &"
    fi

    # Add the command with the sanitised arguments to our .bash_history
    echo $program$options$arguments >> ~/.bash_history

    # Reload the ~/.bash_history into the shell's active history
    history -r

    # execute the last command in ~/.bash_history
    fc -s -1
    }

# cat but just cut at edge of tmux pane
catc () {
    width=$(tmux display-message -p '#{pane_width}')
    options="$@"
    cat $options | cut -c -$(($width-3))
    }

# wrapper for bash script (passes all arguments)
# also displays todo list with numbers
todo () {
    options="$@"
    ~/todo/./todo.sh $options
    catc -n $TODO_PATH/master_todo.md
    }

# mkdir and cd into it
mkcddir () {
    mkdir -p $1 && cd $1
    }

apa () {
    rename 'y/A-Z/a-z/' *.pdf
    rename 's/ /_/g' *.pdf
    rename 's/_.\.//g' *.pdf
    rename 's/,//g' *.pdf
    rename 's/\)\._/)_/g' *.pdf
    rename 's/\._/_[/g' *.pdf
    rename 's/\)\./)]\./g' *.pdf
    rename 's/_&//g' *.pdf
    rename 's/:/-/g' *.pdf
    }

cleanname () {
    rename 'y/A-Z/a-z/' *
    rename 's/ /_/g' *
    rename "s/'//g" *
    rename 's/,//g' *
    rename 's/\./_/g' *  
    # rename 's/_\w+$/.test/g' *
    }

